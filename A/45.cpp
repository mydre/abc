算法训练 猴子分苹果  
时间限制：1.0s   内存限制：256.0MB
提交此题    
问题描述
　　秋天到了，n只猴子采摘了一大堆苹果放到山洞里，约定第二天平分。这些猴子很崇拜猴王孙悟空，所以都想给他留一些苹果。第一只猴子悄悄来到山洞，把苹果平均分成n份，把剩下的m个苹果吃了,然后藏起来一份，最后把剩下的苹果重新合在一起。这些猴子依次悄悄来到山洞，都做同样的操作，恰好每次都剩下了m个苹果。第二天，这些猴子来到山洞，把剩下的苹果分成n分，巧了，还是剩下了m个。问，原来这些猴子至少采了多少个苹果。
输入格式
　　两个整数，n m
输出格式
　　一个整数，表示原来苹果的数目
样例输入
5 1
样例输出
15621
数据规模和约定
　　0<m<n<9
  
  
  /*
  首先假设剩下的苹果数目为k，k从1开始增加
  如果有5个猴子，那么需要往前推6次，而不是5次
  因为两个线段上有三个点
*/
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	for(int k=1;k<=100000000;k++){/*假设分到最后一组的时候，每组包括k个苹果*/
		int q;
		if((k*n+m)%n!=0){
			q=k*n+m;
		}else continue;
		int tot=n+1;/*如果有n个猴子，则需要分n+1次*/
		while(tot--){
			if(q%(n-1)==0){
				q=q/(n-1)*n+m;/*进行递推*/
			}else{
				break;
			}
		}
		if(tot==0){
			cout<<q;/*如果得到了答案，就进行输出，并使用break跳出循环*/
			break;
		}
	}
}
