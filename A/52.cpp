算法训练 K好数  
时间限制：1.0s   内存限制：256.0MB
提交此题   锦囊1   锦囊2
问题描述
如果一个自然数N的K进制表示中任意的相邻的两位都不是相邻的数字，那么我们就说这个数是K好数。求L位K进制数中K好数的数目。例如K = 4，L = 2的时候，所有K好数为11、13、20、22、30、31、33 共7个。由于这个数目很大，请你输出它对1000000007取模后的值。

输入格式
输入包含两个正整数，K和L。

输出格式
输出一个整数，表示答案对1000000007取模后的值。
样例输入
4 2
样例输出
7
数据规模与约定
对于30%的数据，KL <= 106；

对于50%的数据，K <= 16， L <= 10；

对于100%的数据，1 <= K,L <= 100。


/*
  dp[i][j]表示第i为填充数字j时k好数的个数
*/
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int main(){
	int k,l;
	long long dp[110][110]={0};/*dp[i][j]表示第i位填充数字j的时候k好数的个数*/
	cin>>k>>l;/*k进制，l位*/ 
	for(int i=0;i<k;i++){
		dp[1][i]=1;//第1位填充i 
	}
	for(int i=2;i<=l;i++){/*这个是l不是k*/ 
		for(int j=0;j<k;j++){
			for(int u=0;u<k;u++){/*u作为参考变量，通过其可以施加限制条件*/
				if(u!=j+1&&u!=j-1){/**/ 
					dp[i][j]+=dp[i-1][u];
                    dp[i][j]%=1000000007;
				}
			}
		}
	}
	long long sum=0;
	for(int u=1;u<k;u++){/*这一步是从1开始的，因为限制条件中u-1和u+1，0-1就变成了-1,*/
		sum+=dp[l][u];
		sum%=1000000007;
	}
	printf("%lld",sum);
}
