算法训练 Hanoi问题  
时间限制：1.0s   内存限制：512.0MB
提交此题    
问题描述
　　如果将课本上的Hanoi塔问题稍做修改：仍然是给定N只盘子，3根柱子，但是允许每次最多移动相邻的M只盘子（当然移动盘子的数目也可以小于M）,最少需要多少次？
　　例如N=5，M=2时，可以分别将最小的2个盘子、中间的2个盘子以及最大的一个盘子分别看作一个整体，这样可以转变为N=3，M=1的情况，共需要移动7次。
输入格式
　　输入数据仅有一行，包括两个数N和M（0<=M<=N<=8）
输出格式
　　仅输出一个数，表示需要移动的最少次数
样例输入
5 2

样例输出


7
/*
 /*1.汉若塔
说明河内之塔(Towers of Hanoi)是法国人M.Claus(Lucas)于1883年从泰国带至法国的，河内为越战时北越的首都，
即现在的胡志明市；1883年法国数学家 Edouard Lucas曾提及这个故事，
据说创世纪时Benares有一座波罗教塔，是由三支钻石棒（Pag）所支撑，开始时神在第一根棒上放置64个由上至下依由小至大排列的金盘（Disc），
并命令僧侣将所有的金盘从第一根石棒移至第三根石棒，且搬运过程中遵守大盘子在小盘子之下的原则，若每日仅搬一个盘子，则当盘子全数搬运完毕之时，
此塔将毁损，而也就是世界末日来临之时。
解法如果柱子标为ABC，要由A搬至C，在只有一个盘子时，就将它直接搬至C，当有两个盘子，就将B当作辅助柱。如果盘数超过2个，
将第三个以下的盘子遮起来，就很简单了，每次处理两个盘子，也就是：A->B、A ->C、B->C这三个步骤，
而被遮住的部份，其实就是进入程式的递回处理。事实上，若有n个盘子，则移动完毕所需之次数为2^n - 1，
所以当盘数为64时，则所需次数为：264- 1 = 18446744073709551615为5.05390248594782e+16年，
也就是约5000世纪，如果对这数字没什幺概念，就假设每秒钟搬一个盘子好了，也要约5850亿年左右。
*/ 
*/
/*
 汉诺塔问题，盘子个数为n，则需要移动的次数为2的n次方减1
 使用数学函数ceil是把一个浮点数向上取整
*/
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
int cnt;
double N,M;
void hanoi(int n,char A,char B,char C){
	if(n==1){
		cnt++;
		//cout<<"第"<<n<<" 个盘子从 "<<A<<" 移动到 "<<C<<endl; 
	}else{	
		hanoi(n-1,A,C,B);
		//cout<<"第"<<n<<" 个盘子从 "<<A<<" 移动到 "<<C<<endl;
		cnt++;
		hanoi(n-1,B,A,C);
	}
} 
int main(){
	cin>>N>>M;
	N=ceil(N/M);
	hanoi(N,'a','b','c');
	cout<<cnt;
}
