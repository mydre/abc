算法训练 黑色星期五  
时间限制：1.0s   内存限制：512.0MB
提交此题    

问题描述
　　有些西方人比较迷信，如果某个月的13号正好是星期五，他们就会觉得不太吉利，用古人的说法，就是“诸事不宜”。请你编写一个程序，统计出在某个特定的年份中，出现了多少次既是13号又是星期五的情形，以帮助你的迷信朋友解决难题。
　　说明：（1）一年有365天，闰年有366天，所谓闰年，即能被4整除且不能被100整除的年份，或是既能被100整除也能被400整除的年份；（2）已知1998年1月1日是星期四，用户输入的年份肯定大于或等于1998年。
　　输入格式：输入只有一行，即某个特定的年份（大于或等于1998年）。
　　输出格式：输出只有一行，即在这一年中，出现了多少次既是13号又是星期五的情形。
输入输出样例
样例输入
1998
样例输出
3

/*
  输入一个年份，首先根据年份计算出天数，然后计算这个年份的十二个月份的每一个月的13号是否是星期五（根据与1998年1月1号的偏移天数来计算星期）
*/
#include<cstdio>
#include<iostream>
using namespace std;
int cnt;
int day1[12]={31,28,31,30,31,30,31,31,30,31,30,31};//平年 
int day2[12]={31,29,31,30,31,30,31,31,30,31,30,31};//闰年 
int is_run(int year){/*判定是否是闰年*/
	if(year%4==0&&year%100!=0||year%400==0) return 1;
	return 0;
}
int day(int month,int year){/*计算从该年份开始在指定月份的13日的时候的天数的偏移量*/
	int s=0;
	for(int i=1;i<month;i++){
		if(is_run(year)){
			s+=day2[i-1];/*下标是i,而不是month，因为i是变的*/
			//cout<<"saa="<<s<<endl;
		}else{
			s+=day1[i-1];
		//	cout<<"sbb="<<s<<endl;
		}
	}
	s+=13;
	//cout<<"scc="<<s<<endl;
	return s;
}
int main(){
	int ye;
	cin>>ye;/*输入年份*/
	int s=0;
	for(int i=1998;i<ye;i++){/*计算偏移天数*/
		if(is_run(i)){
			s+=366;
		}else{
			s+=365;
		}
	}
	//cout<<s<<endl;
	for(int i=1;i<=12;i++){
		s=s+day(i,ye);	
		
		if((s-1)%7==1)	cnt++;	 	
		//cout<<"month="<<i<<" "<<"s="<<s<<endl;
		
		s=s-day(i,ye);
	}
	cout<<cnt;/*输出该年份满足天数的数目*/
	//cout<<endl<<day(3,1998)<<endl;
	return 0;
}
