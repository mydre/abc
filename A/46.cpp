算法训练 王、后传说  
时间限制：1.0s   内存限制：256.0MB
提交此题    
问题描述
　　地球人都知道，在国际象棋中，后如同太阳，光芒四射，威风八面，它能控制横、坚、斜线位置。
　　看过清宫戏的中国人都知道，后宫乃步步惊心的险恶之地。各皇后都有自己的势力范围，但也总能找到相安无事的办法。
　　所有中国人都知道，皇权神圣，伴君如伴虎，触龙颜者死......
　　现在有一个n*n的皇宫，国王占据他所在位置及周围的共9个格子，这些格子皇后不能使用（如果国王在王宫的边上，占用的格子可能不到9个）。当然，皇后也不会攻击国王。
　　现在知道了国王的位置（x,y）（国王位于第x行第y列，x,y的起始行和列为1），请问，有多少种方案放置n个皇后，使她们不能互相攻击。
输入格式
　　一行，三个整数，皇宫的规模及表示国王的位置
输出格式
　　一个整数，表示放置n个皇后的方案数
样例输入
8 2 2
样例输出
10
数据规模和约定
　　n<=12
  
  
  算法训练 王、后传说  
时间限制：1.0s   内存限制：256.0MB
提交此题    
问题描述
　　地球人都知道，在国际象棋中，后如同太阳，光芒四射，威风八面，它能控制横、坚、斜线位置。
　　看过清宫戏的中国人都知道，后宫乃步步惊心的险恶之地。各皇后都有自己的势力范围，但也总能找到相安无事的办法。
　　所有中国人都知道，皇权神圣，伴君如伴虎，触龙颜者死......
　　现在有一个n*n的皇宫，国王占据他所在位置及周围的共9个格子，这些格子皇后不能使用（如果国王在王宫的边上，占用的格子可能不到9个）。当然，皇后也不会攻击国王。
　　现在知道了国王的位置（x,y）（国王位于第x行第y列，x,y的起始行和列为1），请问，有多少种方案放置n个皇后，使她们不能互相攻击。
输入格式
　　一行，三个整数，皇宫的规模及表示国王的位置
输出格式
　　一个整数，表示放置n个皇后的方案数
样例输入
8 2 2
样例输出
10
数据规模和约定
　　n<=12
  
  
/*
  在本程序中，我们用j表示y，使用cur表示x 
  要注意，x（cur）是从1开始的，不是从0开始的，因为当判断是否和皇上发生碰撞的时候会用到 
*/
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int n,x,y;
int cnt=0;
int vis[3][30];/*vis数组要开的大一点，因为这样才能够包含所有的情况*/ 
int bomp(int x1,int y1){
	for(int i=-1;i<=1;i++){
		for(int j=-1;j<=1;j++){
			if(x1==i+x&&y1==j+y) return 1;
		}
	}
	return 0;
} 
void solve(int cur){/*cur代表放第几个皇后*/ 
	/*cur代表的是x，x是逐渐增大的*/
	if(cur==n+1){
		cnt++;
	}else
	for(int j=1;j<=n;j++){/*对于每一列*/ 
		if(!vis[0][j]&&!vis[1][cur-j+n]&&!vis[2][cur+j]){/*第j列没有访问过，且两个对角线不冲突*/
			if(!bomp(cur,j)){/*没有和皇上发生碰撞*/ 
				vis[0][j]=vis[1][cur-j+n]=vis[2][cur+j]=1;
				solve(cur+1);
				vis[0][j]=vis[1][cur-j+n]=vis[2][cur+j]=0;
			}
		}
	}
}
int main(){
	cin>>n>>x>>y;
	solve(1);/*x是从1开始的*/
	cout<<cnt;
}
