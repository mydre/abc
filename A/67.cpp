
题目标题：翻硬币

    小明正在玩一个“翻硬币”的游戏。

    桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o 表示反面（是小写字母，不是零）。

    比如，可能情形是：**oo***oooo
    
    如果同时翻转左边的两个硬币，则变为：oooo***oooo

    现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？
    我们约定：把翻动相邻的两个硬币叫做一步操作，那么要求：
   
程序输入：
两行等长的字符串，分别表示初始状态和要达到的目标状态。每行的长度<1000

程序输出：
一个整数，表示最小操作步数

例如：
用户输入：
**********
o****o****

程序应该输出：
5

再例如：
用户输入：
*o**o***o***
*o***o**o***

程序应该输出：
1




资源约定：
峰值内存消耗 < 64M
CPU消耗  < 1000ms


请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。

所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。

注意: main函数需要返回0
注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。
注意: 所有依赖的函数必须明确地在源文件中 #include <xxx>， 不能通过工程设置而省略常用头文件。

提交时，注意选择所期望的编译器类型。



/*
  可以使用异或来处理，相同为0，相异为1 
  考虑这种情况：
  ******
  o**o**
  异或结果为： 
  100100 
  010
  001  (j==2的时候A[j+1]==0的条件不满足了)
  此时tot仍然++,同时令i=j+1,这样i是偶数对后面的一个1，外面的for循环结束后自动将i
  加1，这样i就可以匹配下一对1了 
*/
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int A[1100];
int main(){
	char cr1[1100],cr2[1100];
	int len;
	gets(cr1);
	gets(cr2);
	len=strlen(cr1);
	for(int i=0;i<len;i++){
		if(cr1[i]=='*') cr1[i]=1;
		else cr1[i]=0;
		if(cr2[i]=='*') cr2[i]=1;
		else cr2[i]=0;
		A[i]=cr1[i]^cr2[i];
		//cout<<A[i];
	}
	int ans=0,tot=0;
	int flag=0;
	for(int i=0;i<len;i++){
		//if(flag==1) cout<<"is="<<i<<endl;
		if(A[i]==1){
			tot=0;
			for(int j=i;j<len;j++){
				if(A[j+1]==0){
					tot++;
					continue;	
				} 
				else{
					flag=1;
					tot++;
					i=j+1;
					break;
				}
			}
			ans+=tot;
		}
		//if(flag==1) cout<<"ix="<<i<<endl;
	}
	cout<<ans;
}
