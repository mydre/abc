
生命之树

在X森林里，上帝创建了生命之树。

他给每棵树的每个节点（叶子也称为一个节点）上，都标了一个整数，代表这个点的和谐值。
上帝要在这棵树内选出一个非空节点集S，使得对于S中的任意两个点a,b，都存在一个点列 {a, v1, v2, ..., vk, b} 使得这个点列中的每个点都是S里面的元素，
且序列中相邻两个点间有一条边相连。

在这个前提下，上帝要使得S中的点所对应的整数的和尽量大。
这个最大的和就是上帝给生命之树的评分。

经过atm的努力，他已经知道了上帝给每棵树上每个节点上的整数。但是由于 atm 不擅长计算，他不知道怎样有效的求评分。他需要你为他写一个程序来计算一棵树的分数。

「输入格式」
第一行一个整数 n 表示这棵树有 n 个节点。
第二行 n 个整数，依次表示每个节点的评分。
接下来 n-1 行，每行 2 个整数 u, v，表示存在一条 u 到 v 的边。由于这是一棵树，所以是不存在环的。

「输出格式」
输出一行一个数，表示上帝给这棵树的分数。

「样例输入」
5
1 -2 -3 4 5
4 2
3 1
1 2
2 5

「样例输出」
8

「数据范围」
对于 30% 的数据，n <= 10
对于 100% 的数据，0 < n <= 10^5, 每个节点的评分的绝对值不超过 10^6 。

资源约定：
峰值内存消耗 < 256M
CPU消耗  < 3000ms


请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。

所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。

注意: main函数需要返回0
注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。
注意: 所有依赖的函数必须明确地在源文件中 #include <xxx>， 不能通过工程设置而省略常用头文件。

提交时，注意选择所期望的编译器类型。


/*
  树型动态规划
*/
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int N,val[100000],M,head[100000],dp[100000][2],vis[100000];
struct Edge{
	int e;
	int next;
}edges[100000];
void addEdge(int u,int v){/*添加边*/
	edges[++M].e=v;
	edges[M].next=head[u];/**/
	head[u]=M;
}
void dfs(int s){/*这里访问标志的设置非常巧妙，其实访问过的额结点不需要再次访问了，因此不需要在后面令vis[x]=0*/
	dp[s][1]=val[s];
	dp[s][0]=0;
	vis[s]=1;/*设置访问标志*/
	for(int i=head[s];i!=-1;i=edges[i].next){/*查找以s为头结点的所有的边*/
		int v=edges[i].e;/*v代表该边上的子结点*/
		if(!vis[v]){
			dfs(v);
			dp[s][1]+=max(dp[v][0],dp[v][1]);/*父结点访问过，则可以连成一条线，加上即可（子结点的选择有两种状态）*/
		}else{/*则子结点已经被访问过了*/
			dp[s][1]=max(dp[s][1],val[s]);/*父结点的数目不再增加，而是和val[s]（本身结点的值）进行比较，取最大的*/
			dp[s][0]=max(dp[s][0],0);/*父结点没有取，则和0进行比较，0大则为0*/
		}
	}
}
int main(){
	memset(head,-1,sizeof(head));/*初始化所有边的编号为-1*/
	cin>>N;
	for(int i=1;i<=N;i++){
		cin>>val[i];
	}
	int t1,t2;
	for(int i=0;i<N-1;i++){
		cin>>t1>>t2;
		addEdge(t1,t2);/*要添加两次边*/
		addEdge(t2,t1);
	}
	dfs(1);/*进行深度优先遍历*/
	int ans=-1; 
	for(int i=1;i<=N;i++){/*更新最大值*/
		ans=max(ans,dp[i][0]);
		ans=max(ans,dp[i][1]);
	}
	cout<<ans;
}
